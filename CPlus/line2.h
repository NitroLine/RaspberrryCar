#pragma once
#include "opencv2/imgproc.hpp"
#include "opencv2/highgui.hpp"
#include "opencv2/videoio.hpp"
#include "opencv2/core/core.hpp"
using namespace cv;
using namespace std;


//int minold = 320; 				     // изначально предполгаем, что линия будет в центре кадра 
					   // далее в данную переменную будут записываться значение предыдучего центра линии
namespace line2 {
	void MyFilledCircle(Mat img, Point center);


	int FindLine(Mat line, int minold,int View,bool debug = false)
	{

		int N = View;      // номер строки картинки, которую будем анализировать (почти низ картинки)

		int w = 0;        //номер белого пикселя после черной последовательности
		int centr = 0;    //центр черной линии

		int r = 0;        //для массива
		int mas[640];     //больше 640 центров не будет т.к. в принципе пикселей в строке 640


		for (int c = 150; c < line.cols-150; c++)
		{
			int b = c;    //для расчета ширины линии
			int e = b;

			while ((e < 640) && ((line.at<Vec3b>(N, e)[2]) < 50) && ((line.at<Vec3b>(N, e)[1]) < 50) && ((line.at<Vec3b>(N, e)[0]) < 50)) // если черный или темный
			{
				e++; //контролируем длину строки 
			}

			w = e; //номер первого белого пикселя после черной последовательности пикселей

			int lin = e - b; // от конца e отнимаю начало b таким образом определяю ширину черного объекта
			//if ((lin < 100) && (lin > 200)) // проверка линии. По пикселям линия будет иметь некоторый диапазон, если это не СТОП линия или перекресток

			if (lin < 50)
				continue;
			centr = (b + w) / 2; // расчет центра черного объекта

			c = e;               //присваиваем счетчику для for новое значение, чтобы он заного не начал перебирать пиксели откуда начал предыдущий раз 

			mas[r] = centr;      // записываем в массив центр черного объекта
			r++;                 // увеличиваем счетчик для массива, чтобы записать элементы по порядку
		}


		int min = 640;
		for (int i = 0; i < r; i++)         //поиск ближайшего элемента массива (центра черного объекта) к пикселю 320 (координата по Х)
		{
			if (abs(mas[i] - minold) < min) //ВМЕСТО 320 СТАВИМ ЗНАЧЕНИЕ ПРЕДЫДУЩЕГО КАДРА
											//Резкий уход линии в сторону не возможен из-за низкой скорости ТС и конфигурации поля 
											//поэтому ближайшая линия к предыдущему кадру и будет линии, по которой движется робот, 
											//а например не встречная
			{
				min = mas[i];
			}
		}
		if (debug) {
			MyFilledCircle(line, Point(min, N));// рисуем маркер на линии 
			imshow("Line2Debug", line);             //выводим изображение
		}


		return min;

	}

	void MyFilledCircle(Mat img, Point center)
	{
		circle(img,
			center,
			10,                  //радиус круга
			Scalar(0, 255, 0),   //цвет круга
			FILLED,
			LINE_8);
	}
}
